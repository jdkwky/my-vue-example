{"remainingRequest":"/Users/kscit/Documents/study/my-vue-example/node_modules/babel-loader/lib/index.js!/Users/kscit/Documents/study/my-vue-example/node_modules/eslint-loader/index.js??ref--13-0!/Users/kscit/Documents/study/my-vue-example/src/view/canvas/polygonLayer.js","dependencies":[{"path":"/Users/kscit/Documents/study/my-vue-example/src/view/canvas/polygonLayer.js","mtime":1586666396474},{"path":"/Users/kscit/Documents/study/my-vue-example/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/kscit/Documents/study/my-vue-example/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/kscit/Documents/study/my-vue-example/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.fill\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _slicedToArray from \"/Users/kscit/Documents/study/my-vue-example/node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/kscit/Documents/study/my-vue-example/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kscit/Documents/study/my-vue-example/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/kscit/Documents/study/my-vue-example/node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kscit/Documents/study/my-vue-example/node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"/Users/kscit/Documents/study/my-vue-example/node_modules/@babel/runtime-corejs2/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/Users/kscit/Documents/study/my-vue-example/node_modules/@babel/runtime-corejs2/helpers/esm/inherits\";\nimport _defineProperty from \"/Users/kscit/Documents/study/my-vue-example/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport BaseCanvas from \"./baseCanvas\";\n\nvar PolygonLayer =\n/*#__PURE__*/\nfunction (_BaseCanvas) {\n  _inherits(PolygonLayer, _BaseCanvas);\n\n  function PolygonLayer(_ref) {\n    var _this;\n\n    var canvas = _ref.canvas;\n\n    _classCallCheck(this, PolygonLayer);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(PolygonLayer).call(this, canvas));\n\n    _defineProperty(_assertThisInitialized(_this), \"_initOn\", function () {\n      _this._on('eidtEnd', _this.eidtEnd, _assertThisInitialized(_this));\n\n      _this._on('drawEnd', _this.drawEnd, _assertThisInitialized(_this));\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"drawEnd\", function (type, coordinates, coordinate) {\n      if (type == 'polygon') {\n        _this.coordinates = _this.formateCoordinatesScale(coordinates);\n        _this.coordinate = _this.formateCoordinateScale(coordinate);\n\n        _this.clearFlag();\n\n        _this.createMovePolygonPath();\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"eidtEnd\", function () {\n      _this.currentCheckedInfo = {};\n      _this.moveLayersFlag = false;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"clearFlag\", function () {\n      _this.currentCheckedInfo = {};\n      _this.moveLayersFlag = false;\n      _this.checkedIndex = -1;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"imageDargEndCallback\", function () {\n      var coordinates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var coordinate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var loc = arguments.length > 2 ? arguments[2] : undefined;\n      _this.coordinates = _this.formateCoordinatesScale(coordinates);\n      _this.coordinate = _this.formateCoordinateScale(coordinate);\n\n      _this.createMovePolygonPath(loc);\n    });\n\n    if (canvas) {\n      _this._canvas = canvas;\n      _this._context = _this._canvas.getContext('2d');\n      _this.coordinates = [];\n      _this.coordinate = [];\n      _this.fillColor = \"rgba(255,255,255,0.2)\";\n      _this.strokeColor = \"blue\";\n      _this.circleRadius = 3;\n      _this.currentCheckedInfo = {};\n\n      _this._initOn();\n\n      _this.threshold = 10;\n      _this.moveLayersFlag = false;\n    } else {\n      console.error('polygonLayer need canvas');\n    }\n\n    return _this;\n  }\n\n  _createClass(PolygonLayer, [{\n    key: \"setContextProps\",\n\n    /**\n     * 重置绘图状态\n     * @param {*} param0 \n     */\n    value: function setContextProps(_ref2) {\n      var fillColor = _ref2.fillColor,\n          strokeColor = _ref2.strokeColor;\n      this.fillColor = fillColor || this.fillColor;\n      this.strokeColor = strokeColor || this.strokeColor;\n    }\n    /**\n     *\n     * @param {*} points\n     * @param {*} currentPoint\n     * @param {*} zoom\n     * @param {*} diffX\n     * @param {*} diffY\n     * return 返回当前点是否在路径中(路径中)\n     */\n\n  }, {\n    key: \"isPointInPath\",\n    value: function isPointInPath(coordinates, currentPoint) {\n      this._context.beginPath();\n\n      this._context.moveTo(coordinates[0][0], coordinates[0][1]);\n\n      for (var i = coordinates.length - 1; i > -1; --i) {\n        this._context.lineTo(coordinates[i][0], coordinates[i][1]);\n      }\n\n      this._context.closePath();\n\n      if (this._context.isPointInPath(currentPoint[0], currentPoint[1])) {\n        return true;\n      }\n\n      if (this._context.isPointInPath(currentPoint[0] - this.threshold, currentPoint[1])) {\n        return true;\n      }\n\n      if (this._context.isPointInPath(currentPoint[0] - this.threshold, currentPoint[1] - this.threshold)) {\n        return true;\n      }\n\n      if (this._context.isPointInPath(currentPoint[0] + this.threshold, currentPoint[1])) {\n        return true;\n      }\n\n      if (this._context.isPointInPath(currentPoint[0] + this.threshold, currentPoint[1] + this.threshold)) {\n        return true;\n      }\n\n      if (this._context.isPointInPath(currentPoint[0], currentPoint[1] - this.threshold)) {\n        return true;\n      }\n\n      if (this._context.isPointInPath(currentPoint[0], currentPoint[1] + this.threshold)) {\n        return true;\n      }\n    }\n    /**\n     * 将一组多边形中的线段两两连线\n     * @param {Object} points\n     */\n\n  }, {\n    key: \"getLinePath\",\n    value: function getLinePath(points) {\n      var lines = [];\n\n      for (var i = 0, len = points.length; i < len; i++) {\n        if (i < len - 1) {\n          lines.push({\n            p1: [points[i][0], points[i][1]],\n            p2: [points[i + 1][0], points[i + 1][1]]\n          });\n        } else {\n          lines.push({\n            p1: [points[i][0], points[i][1]],\n            p2: [points[0][0], points[0][1]]\n          });\n        }\n      }\n\n      return lines;\n    }\n    /**\n     * 判断鼠标点靠近哪个点\n     * @param {Point} dot\n     * @param {List} coordinates\n     * @param { Number } checkedIndex\n     * \n     */\n\n  }, {\n    key: \"judgeNearLeastDot\",\n    value: function judgeNearLeastDot(checkedIndex, dot) {\n      var _this$coordinates$che = this.coordinates[checkedIndex],\n          paths = _this$coordinates$che.paths,\n          pathId = _this$coordinates$che.pathId;\n      var currentLines = this.getLinePath(paths);\n      var results = [];\n      var resultsMap = {};\n\n      for (var i = 0, len = currentLines.length; i < len; i++) {\n        var x2 = dot[0] ? dot[0] : 0;\n        var y2 = dot[1] ? dot[1] : 0;\n        var p1 = currentLines[i].p1;\n        var p2 = currentLines[i].p2;\n\n        var _p = _slicedToArray(p1, 2),\n            p1X = _p[0],\n            p1Y = _p[1];\n\n        var _p2 = _slicedToArray(p2, 2),\n            p2X = _p2[0],\n            p2Y = _p2[1];\n\n        var l = this.threshold + 1;\n        var x = 0;\n        var y = 0;\n\n        if ((p1X <= x2 && x2 <= p2X || p2X <= x2 && x2 <= p1X) && (p1Y <= y2 && y2 <= p2Y || p2Y <= y2 && y2 <= p1Y)) {\n          var slop = this.calSlop(p1, p2);\n          var verSlop = this.calVerticalSlop(slop);\n          var x1 = p1[0] || 0;\n          var y1 = p1[1] || 0;\n\n          if (slop != 0 && verSlop != 0) {\n            if (y2 == slop * x2 + y1 - slop * y1) {\n              // 点在当前直线上\n              x = x2;\n              y = y2;\n            } else {\n              x = parseFloat((y2 - y1 + slop * x1 - verSlop * x2) / (slop - verSlop));\n              y = parseFloat(slop * x + y1 - slop * x1);\n            }\n          } else {\n            // 垂直于x轴或平行于x轴\n            if (x1 == p2X) {\n              // 平行于y轴\n              x = x1;\n              y = y2;\n            } else if (y1 == p2Y) {\n              // 平行于x轴\n              x = x2;\n              y = y1;\n            }\n          }\n\n          if (p1X <= x && x <= p2X || p2X <= x && x <= p1X && p1Y <= y && y <= p2Y || p2Y <= y && y <= p1Y) {\n            l = parseInt(Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2)));\n          }\n        } else {\n          l = parseInt(Math.sqrt(Math.pow(x2 - p1X, 2) + Math.pow(y2 - p1Y, 2)));\n        } // x y 焦点\n\n\n        var vertex = -1;\n\n        if (l < this.threshold) {\n          // 说明是点在线上\n          var l1 = parseInt(Math.sqrt(Math.pow(p1X - x2, 2) + Math.pow(p1Y - y2, 2)));\n          var l2 = parseInt(Math.sqrt(Math.pow(p2X - x, 2) + Math.pow(p2Y - y, 2)));\n\n          if (l1 < this.threshold) {\n            x = p1X;\n            y = p1Y;\n            vertex = 0;\n          } else if (l2 < this.threshold) {\n            x = p2X;\n            y = p2Y;\n            vertex = 1;\n          }\n        }\n\n        results.push(l);\n        resultsMap[l] = {\n          index: i,\n          value: l,\n          dot: [x, y],\n          checkedIndex: checkedIndex,\n          vertex: vertex,\n          pathId: pathId\n        };\n      }\n\n      if (results.length > 0) {\n        var min = Math.min.apply(Math, results);\n        return resultsMap[min];\n      }\n\n      return null;\n    }\n    /**\n     * 计算靠近两个点的斜率\n     *\n     * @param {Point} line1\n     * @param {Point} line2\n     */\n\n  }, {\n    key: \"calSlop\",\n    value: function calSlop(line1, line2) {\n      if (line1[0] - line2[0] != 0) {\n        return parseFloat((line1[1] - line2[1]) / (line1[0] - line2[0]));\n      }\n\n      return 0;\n    }\n    /**\n     * 计算垂线的斜率\n     * @param {Number} slop\n     */\n\n  }, {\n    key: \"calVerticalSlop\",\n    value: function calVerticalSlop(slop) {\n      if (slop != 0) {\n        return parseFloat(-1 / slop);\n      }\n\n      return 0;\n    }\n    /**\n     * 计算点是否在线左右  阈值可设置\n     * \n     * @param { List<Point> } coordinates\n     * @param { Number } checkedIndex\n     * @param diffX 底层差值x\n     * @param diffY  底层差值y\n     */\n\n  }, {\n    key: \"calcDotNearLine\",\n    value: function calcDotNearLine(coordinates, checkedIndex, dot) {\n      //判断此点距离哪个点最近\n      if (coordinates.length > 0) {\n        var result = this.judgeNearLeastDot(checkedIndex, dot, 10);\n\n        if (result && result.value <= this.threshold) {\n          return result;\n        }\n      }\n\n      return {};\n    }\n    /**\n     * 将编辑图形时产生的点放入到大数组中  修改了数据信息\n     *\n     * params\n     *\n     */\n\n  }, {\n    key: \"editPoints\",\n    value: function editPoints(currentCheckedInfo) {\n      var checkedIndex = currentCheckedInfo.checkedIndex; // 第几条线\n\n      var index = currentCheckedInfo.index;\n      var dot = currentCheckedInfo.dot;\n      var vertex = currentCheckedInfo.vertex;\n      var checkDotIndex = index + vertex;\n\n      if (vertex == -1) {\n        // 说明不是个顶点\n        this.coordinates[checkedIndex].paths.splice(index + 1, 0, [dot[0], dot[1]]);\n\n        this._emit('addPolygonVertex', {\n          pathId: currentCheckedInfo.pathId,\n          dot: dot,\n          index: index + 1\n        });\n\n        checkDotIndex = index + 1;\n      } // 重绘\n\n\n      this.drawAllCheckedPath(checkDotIndex, checkedIndex);\n      return this;\n    }\n    /**\n    * 鼠标移动时将点数据动态更新到数组中  修改了数据信息\n    *\n    * params\n    */\n\n  }, {\n    key: \"editMovePoints\",\n    value: function editMovePoints(currentCheckedInfo, loc) {\n      var checkedIndex = currentCheckedInfo.checkedIndex; // 第几条线\n\n      var index = currentCheckedInfo.index;\n      var vertex = currentCheckedInfo.vertex;\n      var pathId = currentCheckedInfo.pathId;\n      var checkDotIndex = vertex + index;\n      var checkedCoordinate = this.coordinates[checkedIndex].paths;\n\n      if (vertex == -1) {\n        // 说明不是个顶点\n        checkedCoordinate[index + 1] = loc;\n\n        this._emit('changePolygon', {\n          index: index + 1,\n          loc: loc,\n          isVertex: false,\n          pathId: pathId\n        });\n\n        checkDotIndex = index + 1;\n      } else {\n        // 说明是个顶点\n        var i = index + vertex;\n        checkedCoordinate[i] = loc;\n\n        this._emit('changePolygon', {\n          index: i,\n          loc: loc,\n          isVertex: true,\n          pathId: pathId\n        });\n      } // 重绘\n\n\n      this.drawAllCheckedPath(checkDotIndex, checkedIndex);\n      return this;\n    }\n    /**\n     * 绘制非编辑状态情况下路径\n     *\n     * checkedIndex: 当前选中的路径\n     * checkDotIndex : 当前选中的点左边\n     *\n     */\n\n  }, {\n    key: \"drawAllCheckedPath\",\n    value: function drawAllCheckedPath(checkDotIndex, checkedIndex) {\n      var _this2 = this;\n\n      if (this.coordinates.length > 0) {\n        this.coordinates.forEach(function (val, index) {\n          if (checkedIndex != index) {\n            _this2.drawPath(val.paths, true, true);\n          } else {\n            _this2.drawCheckedPath(val.paths, checkDotIndex);\n          }\n        });\n      }\n\n      return this;\n    }\n    /**\n     * 绘制多边形路径\n     * @param {Array} coordinates\n     * @param {Boolean} flag\n     * @param {Boolean} fill\n     * @param { String } fillColor\n     * @param { String } strokeColor\n     */\n\n  }, {\n    key: \"drawPath\",\n    value: function drawPath(coordinates, flag, fill) {\n      if (coordinates.length > 0) {\n        this._context.lineWidth = 1;\n\n        this._context.beginPath();\n\n        this._context.moveTo(coordinates[0][0], coordinates[0][1]);\n\n        for (var i = 1; i < coordinates.length; ++i) {\n          this._context.lineTo(coordinates[i][0], coordinates[i][1]);\n        }\n\n        if (flag) {\n          this._context.closePath();\n        }\n\n        this._context.strokeStyle = this.strokeColor;\n\n        this._context.stroke();\n\n        if (fill) {\n          this._context.fillStyle = this.fillColor;\n\n          this._context.fill();\n        }\n      }\n\n      return this;\n    }\n    /**\n     * 绘制当前数据路径\n     * @param {*} params \n     */\n\n  }, {\n    key: \"createPolygonPath\",\n    value: function createPolygonPath() {\n      if (this.coordinates.length > 0) {\n        var index = this.currentCheckedInfo.index;\n        var vertex = this.currentCheckedInfo.vertex;\n        var checkDotIndex = null;\n\n        if (vertex > -1) {\n          checkDotIndex = vertex + index;\n        }\n\n        this.drawAllCheckedPath(checkDotIndex, this.checkedIndex);\n      }\n\n      if (this.coordinate.length > 0) {\n        this.drawPath(this.coordinate, false, false);\n      }\n\n      return this;\n    }\n    /**\n     * 绘制状态下鼠标move状态下画图\n     *  loc: 当前鼠标点位置\n     */\n\n  }, {\n    key: \"createMovePolygonPath\",\n    value: function createMovePolygonPath(loc) {\n      this.createPolygonPath();\n\n      if (this.coordinate.length > 0) {\n        if (loc) {\n          this._context.lineTo(loc[0], loc[1]);\n\n          this._context.closePath();\n\n          this._context.stroke();\n        }\n      }\n\n      return this;\n    }\n    /**\n     *绘制正常状态中的选中图形状态\n     * @param {List} points\n     * @param { Number } checkDotIndex\n     * @param { String } fillColor\n     * @param { String } strokeColor\n     */\n\n  }, {\n    key: \"drawCheckedPath\",\n    value: function drawCheckedPath(points, checkDotIndex) {\n      // 画线段\n      this.drawPath(points, true, true);\n\n      for (var i = 0; i < points.length; ++i) {\n        this._context.beginPath();\n\n        this._context.moveTo(points[i][0], points[i][1]);\n\n        if (checkDotIndex != i) {\n          this._context.strokeStyle = this.strokeColor;\n\n          this._context.arc(points[i][0], points[i][1], this.circleRadius, 0, 2 * Math.PI, true);\n\n          this._context.fillStyle = 'white';\n\n          this._context.fill();\n\n          this._context.stroke();\n        } else if (checkDotIndex == i) {\n          // 移动的点\n          this._context.strokeStyle = this.fillColor;\n\n          this._context.arc(points[i][0], points[i][1], this.circleRadius, 0, 2 * Math.PI, true);\n\n          this._context.fillStyle = this.strokeColor;\n\n          this._context.fill();\n\n          this._context.stroke();\n        }\n      }\n\n      return this;\n    }\n    /**\n     * 返回当前点击的点 在哪条路径中\n     * @param {Object} currentPoint\n     */\n\n  }, {\n    key: \"checkDotInPath\",\n    value: function checkDotInPath(coordinates, currentPoint) {\n      for (var i = coordinates.length - 1; i > -1; --i) {\n        if (this.isPointInPath(coordinates[i].paths, currentPoint)) {\n          return i;\n        }\n      }\n\n      return -1;\n    }\n    /**\n    * 绘制自动检测的点坐标\n    * @param {Object} params\n    */\n\n  }, {\n    key: \"drawMouseMovePoints\",\n    value: function drawMouseMovePoints(currentCheckedInfo) {\n      this.drawAllCheckedPath(null, this.checkedIndex);\n\n      if (currentCheckedInfo && currentCheckedInfo.dot) {\n        var dot = currentCheckedInfo.dot;\n        var x = dot[0];\n        var y = dot[1];\n\n        this._context.beginPath();\n\n        this._context.moveTo(x, y);\n\n        this._context.fillStyle = this.strokeColor;\n\n        this._context.arc(x, y, this.circleRadius, 0, 2 * Math.PI, false);\n\n        this._context.fill();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"mouseDown\",\n    value: function mouseDown(coordinates, coordinate, loc) {\n      try {\n        this.coordinates = this.formateCoordinatesScale(coordinates);\n        this.coordinate = this.formateCoordinateScale(coordinate);\n        var checkedIndex = this.checkDotInPath(this.coordinates, loc);\n        console.log(checkedIndex, this.currentCheckedInfo, 'currentCheckedInfo');\n\n        if (Object.keys(this.currentCheckedInfo).length <= 0 || checkedIndex == -1) {\n          console.log(Object.keys(this.currentCheckedInfo).length <= 0, checkedIndex == -1, checkedIndex); // 说明当前点并不是在线上\n\n          this.checkedIndex = checkedIndex;\n\n          if (checkedIndex == -1 || this.coordinate.length > 0) {\n            // 证明没有面被选中\n            // 当成点存储\n            console.log('add loc');\n\n            this._emit('addLocToCoordinate', loc);\n\n            this.preAddLoc = loc;\n            this.createMovePolygonPath(loc);\n          } else {\n            // 点在面上\n            var currentCheckedInfo = this.calcDotNearLine(this.coordinates, checkedIndex, loc, 10);\n            this.currentCheckedInfo = currentCheckedInfo;\n\n            if (this.currentCheckedInfo.index > -1) {\n              // 说明存在靠近鼠标点线段， 即需要点 线匹配\n              this.editPoints(this.currentCheckedInfo);\n            } else {\n              //没有靠近鼠标点的线段 即鼠标点在平面中\n              this.drawAllCheckedPath(null, this.checkedIndex);\n            }\n          }\n        } else if (Object.keys(this.currentCheckedInfo).length > 0) {\n          var dot = this.currentCheckedInfo.dot;\n\n          if (Math.abs(dot[0] - loc[0]) < this.threshold && Math.abs(dot[1] - loc[1]) < this.threshold) {\n            // 当前点在线上\n            if (this.checkedIndex === checkedIndex) {\n              if (this.currentCheckedInfo.index > -1) {\n                this.moveLayersFlag = true; // 说明存在靠近鼠标点线段， 即需要点 线匹配\n\n                this.editPoints(this.currentCheckedInfo);\n                return;\n              }\n            }\n          } // 没有选中的路径\n\n\n          this.checkedIndex = checkedIndex;\n          this.drawAllCheckedPath(null, this.checkedIndex);\n          this.currentCheckedInfo = {};\n        }\n      } catch (e) {\n        throw new Error(e);\n      }\n    }\n  }, {\n    key: \"mouseMove\",\n    value: function mouseMove(coordinates, coordinate, loc) {\n      try {\n        this.coordinates = this.formateCoordinatesScale(coordinates);\n        this.coordinate = this.formateCoordinateScale(coordinate);\n        var checkedIndex = this.checkedIndex;\n\n        if (this.coordinate.length > 0) {\n          // 说明是正在绘制新的图形\n          this.createMovePolygonPath(loc);\n          return;\n        } else {\n          if (checkedIndex > -1) {\n            var currentCheckedInfo = this.calcDotNearLine(this.coordinates, checkedIndex, loc, 10);\n\n            if (currentCheckedInfo.index > -1) {\n              // 点在线附近\n              this.drawMouseMovePoints(currentCheckedInfo);\n              this.currentCheckedInfo = currentCheckedInfo;\n              return;\n            }\n          }\n\n          this.drawAllCheckedPath(null, checkedIndex);\n          this.currentCheckedInfo = {};\n        }\n      } catch (e) {\n        console.warn(e, 'polygon mousemove');\n      }\n    }\n  }, {\n    key: \"mouseMoveDrag\",\n    value: function mouseMoveDrag(coordinates, coordinate, loc) {\n      this.coordinates = this.formateCoordinatesScale(coordinates);\n      this.coordinate = this.formateCoordinateScale(coordinate);\n      var checkedIndex = this.checkDotInPath(this.coordinates, loc);\n\n      if (Object.keys(this.currentCheckedInfo).length > 0 && this.checkedIndex == checkedIndex) {\n        this.moveLayersFlag = true;\n\n        this._emit('layersMove', true);\n\n        this.editMovePoints(this.currentCheckedInfo, loc);\n      } else {\n        this.checkedIndex = checkedIndex;\n        this.drawAllCheckedPath(null, this.checkedIndex);\n\n        if (!this.moveLayersFlag) {\n          this._emit('layersMove', false, this.preAddLoc);\n        }\n      }\n    }\n  }]);\n\n  return PolygonLayer;\n}(BaseCanvas);\n\nexport default PolygonLayer;",{"version":3,"sources":["/Users/kscit/Documents/study/my-vue-example/src/view/canvas/polygonLayer.js"],"names":["BaseCanvas","PolygonLayer","canvas","_on","eidtEnd","drawEnd","type","coordinates","coordinate","formateCoordinatesScale","formateCoordinateScale","clearFlag","createMovePolygonPath","currentCheckedInfo","moveLayersFlag","checkedIndex","loc","_canvas","_context","getContext","fillColor","strokeColor","circleRadius","_initOn","threshold","console","error","currentPoint","beginPath","moveTo","i","length","lineTo","closePath","isPointInPath","points","lines","len","push","p1","p2","dot","paths","pathId","currentLines","getLinePath","results","resultsMap","x2","y2","p1X","p1Y","p2X","p2Y","l","x","y","slop","calSlop","verSlop","calVerticalSlop","x1","y1","parseFloat","parseInt","Math","sqrt","pow","vertex","l1","l2","index","value","min","line1","line2","result","judgeNearLeastDot","checkDotIndex","splice","_emit","drawAllCheckedPath","checkedCoordinate","isVertex","forEach","val","drawPath","drawCheckedPath","flag","fill","lineWidth","strokeStyle","stroke","fillStyle","createPolygonPath","arc","PI","checkDotInPath","log","Object","keys","preAddLoc","calcDotNearLine","editPoints","abs","e","Error","drawMouseMovePoints","warn","editMovePoints"],"mappings":"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","sourcesContent":["import BaseCanvas from './baseCanvas';\n\nclass PolygonLayer extends BaseCanvas {\n    constructor(\n        {\n            canvas\n        }\n    ) {\n        super(canvas)\n        if (canvas) {\n            this._canvas = canvas;\n            this._context = this._canvas.getContext('2d');\n            this.coordinates = [];\n            this.coordinate = [];\n            this.fillColor = \"rgba(255,255,255,0.2)\";\n            this.strokeColor = \"blue\";\n            this.circleRadius = 3;\n            this.currentCheckedInfo = {};\n            this._initOn();\n            this.threshold = 10;\n            this.moveLayersFlag = false;\n\n\n\n        } else {\n            console.error('polygonLayer need canvas');\n        }\n    }\n    _initOn = () => {\n        this._on('eidtEnd', this.eidtEnd, this);\n        this._on('drawEnd', this.drawEnd, this)\n    }\n\n    drawEnd = (type, coordinates, coordinate) => {\n        if (type == 'polygon') {\n            this.coordinates = this.formateCoordinatesScale(coordinates);\n            this.coordinate = this.formateCoordinateScale(coordinate);\n            this.clearFlag();\n            this.createMovePolygonPath();\n        }\n    }\n\n    eidtEnd = () => {\n        this.currentCheckedInfo = {};\n        this.moveLayersFlag = false;\n    }\n    clearFlag = () => {\n        this.currentCheckedInfo = {};\n        this.moveLayersFlag = false;\n        this.checkedIndex = -1;\n    }\n    /**\n     * 重置绘图状态\n     * @param {*} param0 \n     */\n    setContextProps({\n        fillColor,\n        strokeColor,\n\n    }) {\n        this.fillColor = fillColor || this.fillColor;\n        this.strokeColor = strokeColor || this.strokeColor;\n    }\n\n    /**\n     *\n     * @param {*} points\n     * @param {*} currentPoint\n     * @param {*} zoom\n     * @param {*} diffX\n     * @param {*} diffY\n     * return 返回当前点是否在路径中(路径中)\n     */\n    isPointInPath(coordinates, currentPoint) {\n        this._context.beginPath();\n        this._context.moveTo(coordinates[0][0], coordinates[0][1]);\n        for (let i = coordinates.length - 1; i > -1; --i) {\n            this._context.lineTo(coordinates[i][0], coordinates[i][1]);\n        }\n        this._context.closePath();\n        if (this._context.isPointInPath(currentPoint[0], currentPoint[1])) {\n            return true;\n        }\n        if (this._context.isPointInPath(currentPoint[0] - this.threshold, currentPoint[1])) {\n            return true;\n        }\n        if (this._context.isPointInPath(currentPoint[0] - this.threshold, currentPoint[1] - this.threshold)) {\n            return true;\n        }\n        if (this._context.isPointInPath(currentPoint[0] + this.threshold, currentPoint[1])) {\n            return true;\n        }\n        if (this._context.isPointInPath(currentPoint[0] + this.threshold, currentPoint[1] + this.threshold)) {\n            return true;\n        }\n        if (this._context.isPointInPath(currentPoint[0], currentPoint[1] - this.threshold)) {\n            return true;\n        }\n        if (this._context.isPointInPath(currentPoint[0], currentPoint[1] + this.threshold)) {\n            return true;\n        }\n    }\n\n    /**\n     * 将一组多边形中的线段两两连线\n     * @param {Object} points\n     */\n    getLinePath(points) {\n        const lines = [];\n        for (let i = 0, len = points.length; i < len; i++) {\n            if (i < len - 1) {\n                lines.push({\n                    p1: [points[i][0], points[i][1]],\n                    p2: [points[i + 1][0], points[i + 1][1]]\n                });\n            } else {\n                lines.push({\n                    p1: [points[i][0], points[i][1]],\n                    p2: [points[0][0], points[0][1]]\n                });\n            }\n        }\n        return lines;\n    }\n\n    /**\n     * 判断鼠标点靠近哪个点\n     * @param {Point} dot\n     * @param {List} coordinates\n     * @param { Number } checkedIndex\n     * \n     */\n    judgeNearLeastDot(checkedIndex, dot) {\n        const { paths, pathId } = this.coordinates[checkedIndex];\n        const currentLines = this.getLinePath(paths);\n\n        const results = [];\n        const resultsMap = {};\n        for (let i = 0, len = currentLines.length; i < len; i++) {\n            const x2 = dot[0] ? dot[0] : 0;\n            const y2 = dot[1] ? dot[1] : 0;\n            const p1 = currentLines[i].p1;\n            const p2 = currentLines[i].p2;\n            const [p1X, p1Y] = p1;\n            const [p2X, p2Y] = p2;\n            let l = this.threshold + 1;\n            let x = 0;\n            let y = 0;\n            if (\n                ((p1X <= x2 && x2 <= p2X) || (p2X <= x2 && x2 <= p1X)) &&\n                ((p1Y <= y2 && y2 <= p2Y) || (p2Y <= y2 && y2 <= p1Y))\n            ) {\n                const slop = this.calSlop(p1, p2);\n                const verSlop = this.calVerticalSlop(slop);\n\n                const x1 = p1[0] || 0;\n                const y1 = p1[1] || 0;\n\n                if (slop != 0 && verSlop != 0) {\n                    if (y2 == slop * x2 + y1 - slop * y1) {\n                        // 点在当前直线上\n                        x = x2;\n                        y = y2;\n                    } else {\n                        x = parseFloat((y2 - y1 + slop * x1 - verSlop * x2) / (slop - verSlop));\n                        y = parseFloat(slop * x + y1 - slop * x1);\n                    }\n                } else {\n                    // 垂直于x轴或平行于x轴\n                    if (x1 == p2X) {\n                        // 平行于y轴\n                        x = x1;\n                        y = y2;\n                    } else if (y1 == p2Y) {\n                        // 平行于x轴\n                        x = x2;\n                        y = y1;\n                    }\n                }\n\n\n                if (\n                    (p1X <= x && x <= p2X) ||\n                    (p2X <= x && x <= p1X && (p1Y <= y && y <= p2Y)) ||\n                    (p2Y <= y && y <= p1Y)\n                ) {\n                    l = parseInt(Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2)));\n                }\n            } else {\n                l = parseInt(Math.sqrt(Math.pow(x2 - p1X, 2) + Math.pow(y2 - p1Y, 2)));\n            }\n\n            // x y 焦点\n            let vertex = -1;\n\n            if (l < this.threshold) {\n                // 说明是点在线上\n                const l1 = parseInt(Math.sqrt(Math.pow(p1X - x2, 2) + Math.pow(p1Y - y2, 2)));\n                const l2 = parseInt(Math.sqrt(Math.pow(p2X - x, 2) + Math.pow(p2Y - y, 2)));\n                if (l1 < this.threshold) {\n                    x = p1X;\n                    y = p1Y;\n                    vertex = 0;\n                } else if (l2 < this.threshold) {\n                    x = p2X;\n                    y = p2Y\n                    vertex = 1;\n                }\n            }\n\n            results.push(l);\n            resultsMap[l] = {\n                index: i,\n                value: l,\n                dot: [\n                    x,\n                    y\n                ],\n                checkedIndex,\n                vertex,\n                pathId\n            };\n        }\n\n        if (results.length > 0) {\n            const min = Math.min(...results);\n\n            return resultsMap[min];\n        }\n        return null;\n    }\n\n    /**\n     * 计算靠近两个点的斜率\n     *\n     * @param {Point} line1\n     * @param {Point} line2\n     */\n    calSlop(line1, line2) {\n        if (line1[0] - line2[0] != 0) {\n            return parseFloat((line1[1] - line2[1]) / (line1[0] - line2[0]));\n        }\n        return 0;\n    }\n    /**\n     * 计算垂线的斜率\n     * @param {Number} slop\n     */\n    calVerticalSlop(slop) {\n        if (slop != 0) {\n            return parseFloat(-1 / slop);\n        }\n        return 0;\n    }\n\n    /**\n     * 计算点是否在线左右  阈值可设置\n     * \n     * @param { List<Point> } coordinates\n     * @param { Number } checkedIndex\n     * @param diffX 底层差值x\n     * @param diffY  底层差值y\n     */\n\n    calcDotNearLine(coordinates, checkedIndex, dot) {\n        //判断此点距离哪个点最近\n        if (coordinates.length > 0) {\n            const result = this.judgeNearLeastDot(checkedIndex, dot, 10);\n            if (result && result.value <= this.threshold) {\n                return result;\n            }\n        }\n        return {};\n    }\n\n    /**\n     * 将编辑图形时产生的点放入到大数组中  修改了数据信息\n     *\n     * params\n     *\n     */\n    editPoints(currentCheckedInfo) {\n\n        const checkedIndex = currentCheckedInfo.checkedIndex;\n        // 第几条线\n        const index = currentCheckedInfo.index;\n        const dot = currentCheckedInfo.dot;\n        const vertex = currentCheckedInfo.vertex;\n        let checkDotIndex = index + vertex;\n        if (vertex == -1) {\n            // 说明不是个顶点\n\n            this.coordinates[checkedIndex].paths.splice(index + 1, 0, [dot[0], dot[1]]);\n            this._emit('addPolygonVertex', {\n                pathId: currentCheckedInfo.pathId,\n                dot,\n                index: index + 1\n            });\n            checkDotIndex = index + 1;\n        }\n        // 重绘\n        this.drawAllCheckedPath(checkDotIndex, checkedIndex);\n        return this;\n    }\n\n    /**\n * 鼠标移动时将点数据动态更新到数组中  修改了数据信息\n *\n * params\n */\n    editMovePoints(currentCheckedInfo, loc) {\n\n        const checkedIndex = currentCheckedInfo.checkedIndex;\n        // 第几条线\n        const index = currentCheckedInfo.index;\n        const vertex = currentCheckedInfo.vertex;\n        const pathId = currentCheckedInfo.pathId;\n\n        let checkDotIndex = vertex + index;\n        const checkedCoordinate = this.coordinates[checkedIndex].paths;\n        if (vertex == -1) {\n            // 说明不是个顶点\n            checkedCoordinate[index + 1] = loc;\n            this._emit('changePolygon', {\n                index: index + 1,\n                loc,\n                isVertex: false,\n                pathId\n            });\n            checkDotIndex = index + 1;\n        } else {\n            // 说明是个顶点\n            const i = index + vertex;\n            checkedCoordinate[i] = loc;\n            this._emit('changePolygon', {\n                index: i,\n                loc,\n                isVertex: true,\n                pathId\n            });\n\n        }\n\n        // 重绘\n        this.drawAllCheckedPath(\n            checkDotIndex,\n            checkedIndex,\n        );\n        return this;\n    }\n\n    /**\n     * 绘制非编辑状态情况下路径\n     *\n     * checkedIndex: 当前选中的路径\n     * checkDotIndex : 当前选中的点左边\n     *\n     */\n    drawAllCheckedPath(checkDotIndex, checkedIndex) {\n\n        if (this.coordinates.length > 0) {\n            this.coordinates.forEach((val, index) => {\n                if (checkedIndex != index) {\n                    this.drawPath(val.paths, true, true);\n                } else {\n                    this.drawCheckedPath(\n                        val.paths,\n                        checkDotIndex,\n                    );\n                }\n            });\n        }\n        return this;\n    }\n\n    /**\n     * 绘制多边形路径\n     * @param {Array} coordinates\n     * @param {Boolean} flag\n     * @param {Boolean} fill\n     * @param { String } fillColor\n     * @param { String } strokeColor\n     */\n    drawPath(\n        coordinates,\n        flag,\n        fill,\n    ) {\n        if (coordinates.length > 0) {\n            this._context.lineWidth = 1;\n            this._context.beginPath();\n            this._context.moveTo(coordinates[0][0], coordinates[0][1]);\n\n            for (let i = 1; i < coordinates.length; ++i) {\n\n                this._context.lineTo(coordinates[i][0], coordinates[i][1]);\n\n            }\n            if (flag) {\n                this._context.closePath();\n            }\n\n            this._context.strokeStyle = this.strokeColor;\n\n            this._context.stroke();\n            if (fill) {\n\n                this._context.fillStyle = this.fillColor;\n                this._context.fill();\n            }\n        }\n        return this;\n    }\n\n    /**\n     * 绘制当前数据路径\n     * @param {*} params \n     */\n    createPolygonPath() {\n        if (this.coordinates.length > 0) {\n            const index = this.currentCheckedInfo.index;\n            const vertex = this.currentCheckedInfo.vertex;\n            let checkDotIndex = null;\n            if (vertex > -1) {\n                checkDotIndex = vertex + index;\n            }\n            this.drawAllCheckedPath(checkDotIndex, this.checkedIndex);\n        }\n        if (this.coordinate.length > 0) {\n            this.drawPath(this.coordinate, false, false);\n        }\n        return this;\n    }\n\n    /**\n     * 绘制状态下鼠标move状态下画图\n     *  loc: 当前鼠标点位置\n     */\n    createMovePolygonPath(loc) {\n        this.createPolygonPath();\n        if (this.coordinate.length > 0) {\n            if (loc) {\n                this._context.lineTo(loc[0], loc[1]);\n                this._context.closePath();\n\n                this._context.stroke();\n            }\n        }\n        return this;\n    }\n\n    /**\n     *绘制正常状态中的选中图形状态\n     * @param {List} points\n     * @param { Number } checkDotIndex\n     * @param { String } fillColor\n     * @param { String } strokeColor\n     */\n\n    drawCheckedPath(points, checkDotIndex) {\n        // 画线段\n        this.drawPath(points, true, true);\n        for (let i = 0; i < points.length; ++i) {\n            this._context.beginPath();\n            this._context.moveTo(points[i][0], points[i][1]);\n            if (checkDotIndex != i) {\n                this._context.strokeStyle = this.strokeColor;\n                this._context.arc(points[i][0], points[i][1], this.circleRadius, 0, 2 * Math.PI, true);\n                this._context.fillStyle = 'white';\n                this._context.fill();\n                this._context.stroke();\n            } else if (checkDotIndex == i) {\n                // 移动的点\n                this._context.strokeStyle = this.fillColor;\n                this._context.arc(points[i][0], points[i][1], this.circleRadius, 0, 2 * Math.PI, true);\n                this._context.fillStyle = this.strokeColor;\n                this._context.fill();\n                this._context.stroke();\n            }\n        }\n        return this;\n    }\n    /**\n     * 返回当前点击的点 在哪条路径中\n     * @param {Object} currentPoint\n     */\n    checkDotInPath(coordinates, currentPoint) {\n        for (let i = coordinates.length - 1; i > -1; --i) {\n            if (this.isPointInPath(coordinates[i].paths, currentPoint)) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    /**\n * 绘制自动检测的点坐标\n * @param {Object} params\n */\n    drawMouseMovePoints(currentCheckedInfo) {\n\n\n        this.drawAllCheckedPath(null, this.checkedIndex);\n        if (currentCheckedInfo && currentCheckedInfo.dot) {\n            const dot = currentCheckedInfo.dot;\n            const x = dot[0];\n            const y = dot[1];\n            this._context.beginPath();\n            this._context.moveTo(x, y);\n            this._context.fillStyle = this.strokeColor;\n            this._context.arc(x, y, this.circleRadius, 0, 2 * Math.PI, false);\n            this._context.fill();\n        }\n        return this;\n    }\n\n    imageDargEndCallback = (coordinates = [], coordinate = [], loc) => {\n\n        this.coordinates = this.formateCoordinatesScale(coordinates);\n        this.coordinate = this.formateCoordinateScale(coordinate);\n        this.createMovePolygonPath(loc);\n    }\n\n    mouseDown(coordinates, coordinate, loc) {\n        try {\n\n            this.coordinates = this.formateCoordinatesScale(coordinates);\n            this.coordinate = this.formateCoordinateScale(coordinate);\n\n\n            const checkedIndex = this.checkDotInPath(this.coordinates, loc);\n            console.log(checkedIndex, this.currentCheckedInfo, 'currentCheckedInfo');\n\n\n\n            if (Object.keys(this.currentCheckedInfo).length <= 0 || checkedIndex == -1) {\n                console.log(Object.keys(this.currentCheckedInfo).length <= 0, checkedIndex == -1, checkedIndex);\n\n                // 说明当前点并不是在线上\n                this.checkedIndex = checkedIndex;\n                if (checkedIndex == -1 || this.coordinate.length > 0) {\n                    // 证明没有面被选中\n                    // 当成点存储\n                    console.log('add loc');\n\n                    this._emit('addLocToCoordinate', loc);\n                    this.preAddLoc = loc;\n                    this.createMovePolygonPath(loc);\n                } else {\n                    // 点在面上\n                    const currentCheckedInfo = this.calcDotNearLine(\n                        this.coordinates,\n                        checkedIndex,\n                        loc,\n                        10\n                    );\n\n                    this.currentCheckedInfo = currentCheckedInfo;\n\n                    if (this.currentCheckedInfo.index > -1) {\n                        // 说明存在靠近鼠标点线段， 即需要点 线匹配\n                        this.editPoints(this.currentCheckedInfo);\n                    } else {\n                        //没有靠近鼠标点的线段 即鼠标点在平面中\n\n                        this.drawAllCheckedPath(null, this.checkedIndex);\n                    }\n                }\n            } else if (Object.keys(this.currentCheckedInfo).length > 0) {\n                const { dot } = this.currentCheckedInfo;\n\n                if (Math.abs(dot[0] - loc[0]) < this.threshold && Math.abs(dot[1] - loc[1]) < this.threshold) {\n                    // 当前点在线上\n                    if (this.checkedIndex === checkedIndex) {\n                        if (this.currentCheckedInfo.index > -1) {\n                            this.moveLayersFlag = true;\n                            // 说明存在靠近鼠标点线段， 即需要点 线匹配\n                            this.editPoints(this.currentCheckedInfo);\n                            return;\n                        }\n                    }\n                }\n                // 没有选中的路径\n                this.checkedIndex = checkedIndex;\n                this.drawAllCheckedPath(null, this.checkedIndex);\n                this.currentCheckedInfo = {};\n\n\n            }\n        } catch (e) {\n            throw new Error(e);\n        }\n    }\n\n    mouseMove(coordinates, coordinate, loc) {\n        try {\n            this.coordinates = this.formateCoordinatesScale(coordinates);\n            this.coordinate = this.formateCoordinateScale(coordinate);\n            const { checkedIndex } = this;\n\n\n            if (this.coordinate.length > 0) {\n                // 说明是正在绘制新的图形\n                this.createMovePolygonPath(loc);\n                return;\n            } else {\n                if (checkedIndex > -1) {\n                    const currentCheckedInfo = this.calcDotNearLine(this.coordinates, checkedIndex, loc, 10);\n\n                    if (currentCheckedInfo.index > -1) {\n                        // 点在线附近\n                        this.drawMouseMovePoints(currentCheckedInfo);\n                        this.currentCheckedInfo = currentCheckedInfo;\n                        return;\n                    }\n                }\n                this.drawAllCheckedPath(null, checkedIndex);\n                this.currentCheckedInfo = {};\n            }\n        } catch (e) {\n            console.warn(e, 'polygon mousemove')\n        }\n    }\n\n    mouseMoveDrag(coordinates, coordinate, loc) {\n        this.coordinates = this.formateCoordinatesScale(coordinates);\n        this.coordinate = this.formateCoordinateScale(coordinate);\n        const checkedIndex = this.checkDotInPath(this.coordinates, loc);\n\n        if ((Object.keys(this.currentCheckedInfo).length > 0 && this.checkedIndex == checkedIndex)) {\n            this.moveLayersFlag = true;\n            this._emit('layersMove', true);\n            this.editMovePoints(\n                this.currentCheckedInfo,\n                loc\n            );\n        } else {\n            this.checkedIndex = checkedIndex;\n            this.drawAllCheckedPath(null, this.checkedIndex);\n            if (!this.moveLayersFlag) {\n                this._emit('layersMove', false, this.preAddLoc);\n            }\n        }\n    }\n\n\n\n}\n\nexport default PolygonLayer;"]}]}