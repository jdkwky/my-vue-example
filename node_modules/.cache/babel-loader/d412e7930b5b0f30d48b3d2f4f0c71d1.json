{"remainingRequest":"/Users/kscit/Documents/study/my-vue-example/node_modules/babel-loader/lib/index.js!/Users/kscit/Documents/study/my-vue-example/node_modules/eslint-loader/index.js??ref--13-0!/Users/kscit/Documents/study/my-vue-example/src/view/canvas/util.js","dependencies":[{"path":"/Users/kscit/Documents/study/my-vue-example/src/view/canvas/util.js","mtime":1586665770220},{"path":"/Users/kscit/Documents/study/my-vue-example/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/kscit/Documents/study/my-vue-example/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/kscit/Documents/study/my-vue-example/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import _slicedToArray from \"/Users/kscit/Documents/study/my-vue-example/node_modules/@babel/runtime-corejs2/helpers/esm/slicedToArray\";\n\n/**\n *\n * @param {*} points\n * @param {*} currentPoint\n * @param {*} zoom\n * @param {*} diffX\n * @param {*} diffY\n * return 返回当前点是否在路径中(路径中)\n */\nfunction isPointInMutilPath(coordinates, currentPoint) {\n  var threshold = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n\n  var _context = arguments.length > 3 ? arguments[3] : undefined;\n\n  _context.beginPath();\n\n  _context.moveTo(coordinates[0][0], coordinates[0][1]);\n\n  for (var i = coordinates.length - 1; i > -1; --i) {\n    _context.lineTo(coordinates[i][0], coordinates[i][1]);\n  }\n\n  _context.closePath();\n\n  if (_context.isPointInPath(currentPoint[0], currentPoint[1])) {\n    return true;\n  }\n\n  if (_context.isPointInPath(currentPoint[0] - threshold, currentPoint[1])) {\n    return true;\n  }\n\n  if (_context.isPointInPath(currentPoint[0] - threshold, currentPoint[1] - threshold)) {\n    return true;\n  }\n\n  if (_context.isPointInPath(currentPoint[0] + threshold, currentPoint[1])) {\n    return true;\n  }\n\n  if (_context.isPointInPath(currentPoint[0] + threshold, currentPoint[1] + threshold)) {\n    return true;\n  }\n\n  if (_context.isPointInPath(currentPoint[0], currentPoint[1] - threshold)) {\n    return true;\n  }\n\n  if (_context.isPointInPath(currentPoint[0], currentPoint[1] + threshold)) {\n    return true;\n  }\n}\n/**\n *  判断是否在矩形路径中\n */\n\n\nfunction isPointInRectPath(coordinates, pos, threshold, _context) {\n  var _ref = coordinates || [],\n      _ref2 = _slicedToArray(_ref, 2),\n      pos1 = _ref2[0],\n      pos2 = _ref2[1];\n\n  if (pos1 && pos2) {\n    _context.beginPath();\n\n    _context.rect(pos1[0], pos1[1], pos2[0] - pos1[0], pos2[1] - pos1[1]);\n\n    if (_context.isPointInPath(pos[0], pos[1])) {\n      return true;\n    }\n\n    if (_context.isPointInPath(pos[0] + threshold, pos[1])) {\n      return true;\n    }\n\n    if (_context.isPointInPath(pos[0], pos[1] + threshold)) {\n      return true;\n    }\n\n    if (_context.isPointInPath(pos[0] + threshold, pos[1] + threshold)) {\n      return true;\n    }\n\n    if (_context.isPointInPath(pos[0] - threshold, pos[1])) {\n      return true;\n    }\n\n    if (_context.isPointInPath(pos[0] - threshold, pos[1] - threshold)) {\n      return true;\n    }\n\n    if (_context.isPointInPath(pos[0] + threshold, pos[1] + threshold)) {\n      return true;\n    }\n\n    return false;\n  }\n\n  return false;\n}\n/**\n     * 计算靠近两个点的斜率\n     *\n     * @param {Point} line1\n     * @param {Point} line2\n     */\n\n\nfunction _calSlop(line1, line2) {\n  if (line1[0] - line2[0] != 0) {\n    return parseFloat((line1[1] - line2[1]) / (line1[0] - line2[0]));\n  }\n\n  return 0;\n}\n/**\n * 计算垂线的斜率\n * @param {Number} slop\n */\n\n\nfunction _calVerticalSlop(slop) {\n  if (slop != 0) {\n    return parseFloat(-1 / slop);\n  }\n\n  return 0;\n}\n/**\n* 判断点是否在线上\n* @param {*} dot \n* @param {*} line \n*/\n\n\nfunction isPointInLinePath(line, dot, threshold) {\n  var x2 = dot[0] ? dot[0] : 0;\n  var y2 = dot[1] ? dot[1] : 0;\n  var p1 = line[0];\n  var p2 = line[1];\n\n  var _p = _slicedToArray(p1, 2),\n      p1X = _p[0],\n      p1Y = _p[1];\n\n  var _p2 = _slicedToArray(p2, 2),\n      p2X = _p2[0],\n      p2Y = _p2[1];\n\n  var l = threshold + 1;\n  var x = 0;\n  var y = 0;\n\n  if ((p1X <= x2 && x2 <= p2X || p2X <= x2 && x2 <= p1X) && (p1Y <= y2 && y2 <= p2Y || p2Y <= y2 && y2 <= p1Y)) {\n    var slop = _calSlop(p1, p2);\n\n    var verSlop = _calVerticalSlop(slop);\n\n    var x1 = p1[0] || 0;\n    var y1 = p1[1] || 0;\n\n    if (slop != 0 && verSlop != 0) {\n      if (y2 == slop * x2 + y1 - slop * y1) {\n        // 点在当前直线上\n        x = x2;\n        y = y2;\n      } else {\n        x = parseFloat((y2 - y1 + slop * x1 - verSlop * x2) / (slop - verSlop));\n        y = parseFloat(slop * x + y1 - slop * x1);\n      }\n    } else {\n      // 垂直于x轴或平行于x轴\n      if (x1 == p2X) {\n        // 平行于y轴\n        x = x1;\n        y = y2;\n      } else if (y1 == p2Y) {\n        // 平行于x轴\n        x = x2;\n        y = y1;\n      }\n    }\n\n    if (p1X <= x && x <= p2X || p2X <= x && x <= p1X && p1Y <= y && y <= p2Y || p2Y <= y && y <= p1Y) {\n      l = parseInt(Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2)));\n    }\n  }\n\n  if (l < threshold) {\n    // 说明是点在线上\n    return true;\n  }\n\n  return false;\n}\n\nfunction calcArrowH(sp, ep) {\n  var theta = Math.atan((ep[0] - sp[0]) / (ep[1] - sp[1]));\n\n  var cep = _scrollXOY(ep, -1 * theta);\n\n  var csp = _scrollXOY(sp, -1 * theta);\n\n  var ch1 = [0, 0];\n  var ch2 = [0, 0];\n  var l = cep[1] - csp[1];\n  ch1[0] = cep[0] + l * 0.025;\n  ch1[1] = cep[1] - l * 0.05;\n  ch2[0] = cep[0] - l * 0.025;\n  ch2[1] = cep[1] - l * 0.05;\n\n  var h1 = _scrollXOY(ch1, theta);\n\n  var h2 = _scrollXOY(ch2, theta);\n\n  return [h1, h2];\n} //旋转坐标\n\n\nfunction _scrollXOY(p, theta) {\n  return [p[0] * Math.cos(theta) + p[1] * Math.sin(theta), p[1] * Math.cos(theta) - p[0] * Math.sin(theta)];\n}\n/**\n * 计算点是否在箭头坐标内\n * @param {*} line \n * @param {*} dot \n * @param {*} threshold \n */\n\n\nfunction isPointInArrowPath(line, dot, threshold) {\n  var flag1 = isPointInLinePath(line, dot, threshold);\n  var lines = calcArrowH(line[0], line[1]);\n  var flag2 = isPointInLinePath([lines[0], line[1]], dot, threshold);\n  var flag3 = isPointInLinePath([lines[1], line[1]], dot, threshold);\n  return flag1 || flag2 || flag3;\n}\n\nexport { isPointInMutilPath, isPointInRectPath, isPointInLinePath, calcArrowH, isPointInArrowPath };",{"version":3,"sources":["/Users/kscit/Documents/study/my-vue-example/src/view/canvas/util.js"],"names":["isPointInMutilPath","coordinates","currentPoint","threshold","_context","beginPath","moveTo","i","length","lineTo","closePath","isPointInPath","isPointInRectPath","pos","pos1","pos2","rect","_calSlop","line1","line2","parseFloat","_calVerticalSlop","slop","isPointInLinePath","line","dot","x2","y2","p1","p2","p1X","p1Y","p2X","p2Y","l","x","y","verSlop","x1","y1","parseInt","Math","sqrt","pow","calcArrowH","sp","ep","theta","atan","cep","_scrollXOY","csp","ch1","ch2","h1","h2","p","cos","sin","isPointInArrowPath","flag1","lines","flag2","flag3"],"mappings":"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","sourcesContent":["/**\n *\n * @param {*} points\n * @param {*} currentPoint\n * @param {*} zoom\n * @param {*} diffX\n * @param {*} diffY\n * return 返回当前点是否在路径中(路径中)\n */\nfunction isPointInMutilPath(\n    coordinates,\n    currentPoint,\n    threshold = 10,\n    _context\n) {\n    _context.beginPath();\n    _context.moveTo(coordinates[0][0], coordinates[0][1]);\n    for (let i = coordinates.length - 1; i > -1; --i) {\n        _context.lineTo(coordinates[i][0], coordinates[i][1]);\n    }\n    _context.closePath();\n    if (_context.isPointInPath(currentPoint[0], currentPoint[1])) {\n        return true;\n    }\n    if (_context.isPointInPath(currentPoint[0] - threshold, currentPoint[1])) {\n        return true;\n    }\n    if (\n        _context.isPointInPath(\n            currentPoint[0] - threshold,\n            currentPoint[1] - threshold\n        )\n    ) {\n        return true;\n    }\n    if (_context.isPointInPath(currentPoint[0] + threshold, currentPoint[1])) {\n        return true;\n    }\n    if (\n        _context.isPointInPath(\n            currentPoint[0] + threshold,\n            currentPoint[1] + threshold\n        )\n    ) {\n        return true;\n    }\n    if (_context.isPointInPath(currentPoint[0], currentPoint[1] - threshold)) {\n        return true;\n    }\n    if (_context.isPointInPath(currentPoint[0], currentPoint[1] + threshold)) {\n        return true;\n    }\n}\n\n/**\n *  判断是否在矩形路径中\n */\nfunction isPointInRectPath(coordinates, pos, threshold, _context) {\n    const [pos1, pos2] = coordinates || [];\n    if (pos1 && pos2) {\n        _context.beginPath();\n        _context.rect(pos1[0], pos1[1], pos2[0] - pos1[0], pos2[1] - pos1[1]);\n        if (_context.isPointInPath(pos[0], pos[1])) {\n            return true;\n        }\n        if (_context.isPointInPath(pos[0] + threshold, pos[1])) {\n            return true;\n        }\n        if (_context.isPointInPath(pos[0], pos[1] + threshold)) {\n            return true;\n        }\n        if (_context.isPointInPath(pos[0] + threshold, pos[1] + threshold)) {\n            return true;\n        }\n        if (_context.isPointInPath(pos[0] - threshold, pos[1])) {\n            return true;\n        }\n        if (_context.isPointInPath(pos[0] - threshold, pos[1] - threshold)) {\n            return true;\n        }\n        if (_context.isPointInPath(pos[0] + threshold, pos[1] + threshold)) {\n            return true;\n        }\n        return false;\n    }\n\n    return false;\n}\n\n/**\n     * 计算靠近两个点的斜率\n     *\n     * @param {Point} line1\n     * @param {Point} line2\n     */\nfunction _calSlop(line1, line2) {\n    if (line1[0] - line2[0] != 0) {\n        return parseFloat((line1[1] - line2[1]) / (line1[0] - line2[0]));\n    }\n    return 0;\n}\n/**\n * 计算垂线的斜率\n * @param {Number} slop\n */\nfunction _calVerticalSlop(slop) {\n    if (slop != 0) {\n        return parseFloat(-1 / slop);\n    }\n    return 0;\n}\n\n/**\n* 判断点是否在线上\n* @param {*} dot \n* @param {*} line \n*/\nfunction isPointInLinePath(line, dot, threshold) {\n    const x2 = dot[0] ? dot[0] : 0;\n    const y2 = dot[1] ? dot[1] : 0;\n    const p1 = line[0];\n    const p2 = line[1];\n    const [p1X, p1Y] = p1;\n    const [p2X, p2Y] = p2;\n    let l = threshold + 1;\n    let x = 0;\n    let y = 0;\n    if (\n        ((p1X <= x2 && x2 <= p2X) || (p2X <= x2 && x2 <= p1X)) &&\n        ((p1Y <= y2 && y2 <= p2Y) || (p2Y <= y2 && y2 <= p1Y))\n    ) {\n        const slop = _calSlop(p1, p2);\n        const verSlop = _calVerticalSlop(slop);\n\n        const x1 = p1[0] || 0;\n        const y1 = p1[1] || 0;\n\n        if (slop != 0 && verSlop != 0) {\n            if (y2 == slop * x2 + y1 - slop * y1) {\n                // 点在当前直线上\n                x = x2;\n                y = y2;\n            } else {\n                x = parseFloat(\n                    (y2 - y1 + slop * x1 - verSlop * x2) / (slop - verSlop)\n                );\n                y = parseFloat(slop * x + y1 - slop * x1);\n            }\n        } else {\n            // 垂直于x轴或平行于x轴\n            if (x1 == p2X) {\n                // 平行于y轴\n                x = x1;\n                y = y2;\n            } else if (y1 == p2Y) {\n                // 平行于x轴\n                x = x2;\n                y = y1;\n            }\n        }\n\n        if (\n            (p1X <= x && x <= p2X) ||\n            (p2X <= x && x <= p1X && (p1Y <= y && y <= p2Y)) ||\n            (p2Y <= y && y <= p1Y)\n        ) {\n            l = parseInt(Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2)));\n        }\n    }\n\n    if (l < threshold) {\n        // 说明是点在线上\n        return true;\n    }\n    return false;\n}\n\nfunction calcArrowH(sp, ep) {\n    var theta = Math.atan((ep[0] - sp[0]) / (ep[1] - sp[1]));\n    var cep = _scrollXOY(ep, -1 * theta);\n    var csp = _scrollXOY(sp, -1 * theta);\n    var ch1 = [0, 0];\n    var ch2 = [0, 0];\n    var l = cep[1] - csp[1];\n    ch1[0] = cep[0] + l * 0.025;\n    ch1[1] = cep[1] - l * 0.05;\n    ch2[0] = cep[0] - l * 0.025;\n    ch2[1] = cep[1] - l * 0.05;\n    var h1 = _scrollXOY(ch1, theta);\n    var h2 = _scrollXOY(ch2, theta);\n    return [h1, h2];\n}\n//旋转坐标\nfunction _scrollXOY(p, theta) {\n    return [\n        p[0] * Math.cos(theta) + p[1] * Math.sin(theta),\n        p[1] * Math.cos(theta) - p[0] * Math.sin(theta)\n    ];\n}\n\n/**\n * 计算点是否在箭头坐标内\n * @param {*} line \n * @param {*} dot \n * @param {*} threshold \n */\nfunction isPointInArrowPath(line, dot, threshold) {\n    const flag1 = isPointInLinePath(line, dot, threshold);\n    const lines = calcArrowH(line[0], line[1]);\n\n    const flag2 = isPointInLinePath([lines[0], line[1]], dot, threshold);\n    const flag3 = isPointInLinePath([lines[1], line[1]], dot, threshold);\n\n    return flag1 || flag2 || flag3;\n}\n\nexport {\n    isPointInMutilPath,\n    isPointInRectPath,\n    isPointInLinePath,\n    calcArrowH,\n    isPointInArrowPath\n};\n"]}]}